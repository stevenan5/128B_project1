\documentclass[12pt]{article}
 
\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amsthm,amssymb}
\usepackage{mathtools}
\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}

\newenvironment{problem}[2][Problem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2}]}{\end{trivlist}}
\newenvironment{exercise}[2][Exercise]{\begin{trivlist}
\item[\hskip \labelsep {\small\bfseries #1}\hskip \labelsep {\small\bfseries #2}]}{\end{trivlist}}
\newenvironment{epart}[2][Part]{\begin{trivlist}
\item[\hskip \labelsep {\footnotesize\bfseries #1}\hskip \labelsep {\footnotesize\bfseries #2}]}{\end{trivlist}}

\DeclarePairedDelimiter\abs{\lvert}{\rvert}
\DeclarePairedDelimiter\norm{\lVert}{\rVert}

\makeatletter
\let\oldabs\abs
\def\abs{\@ifstar{\oldabs}{\oldabs*}}

\let\oldnorm\norm
\def\norm{\@ifstar{\oldnorm}{\oldnorm*}}
\makeatother

\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
 
\begin{document}
 
\title{Project 1}
\author{Steven An, Kyle Cox, Sangwon Yoon}
\date{Feburary 21, 2018}
\maketitle

\subsection*{Distribution of work}
Even though most of the commits are by Steven, he was the one who put the code on his computer to test as he had the fastest computer.
Case in point is where one member ran the whole program for 45 minutes to no avail while finished in under 11 minutes on Steven's computer.
The pseudo code was written as a group effort and then handed off.
All members of the group contributed to the debugging effort in person.


\subsection*{Part (i)}
See attached MatLab document.
The code from p. 100 is implemented with the \textit{parfor} instead of the \textit{for} and the inline function to anonymous function to save computation time.
Computation time for the first figure went from 1 minute 10 seconds to less than 5 seconds.

\subsection*{Part (ii)}
When $\abs{z} > 2$, then the point is considered to diverge and the initial value in the orbit is not changed from 2 (to represent white in the custom colormap).
Changing the initial values, $z_0$, results in showing either more or less of the fractal.
In the code attached, the range of initial values was increased so that the full fractal can be seen.

\subsection*{Part (iii)}
Program implemented as detailed.
The Julia sets that are the results match the filled Julia sets computed in (ii).
The code that is commented out between lines 74 and 87 fit the list that contains the Julia set to a matrix.
This computation as written is extremely costly and was only done once. 
The result was stored in ``part\textunderscore iii\textunderscore matrix\textunderscore data.mat'' for use in the next part.

\subsection*{Part (iv)}
The \emph{fractal dimension} is a measure of roughness of an object. If one thinks of an object as having a sort of mass, then the fractal dimension is the power by which it's mass changes as its size is scaled. 
When the object is placed on a grid, its mass can be visualized as the number of boxes touched by the object. As the object (or equivalently the grid) scales in size, then the mass will scale by the scaling factor raised to its fractal dimension. 
That is, if an object touches $n$ boxes at size $1$, and touches $m$ boxes at size $\frac{1}{2}$, then its fractal dimension $d$ is given by $d\approx\log_{2}{\frac{m}{n}}$. 
To empirically test this, we can measure the change in mass for many different scaling factors, take the log of the output and find the slope $\left(d\right)$ with linear regression. From Bisoi and Mishra 2000, we use the Reticular Cell Counting Method and Keller's Approach to measure the fractal dimension of the objects produced in part iii.\\
We only use six data points for each, but find that the cell counting method provides a very good measurement for the 1-dimensional circle ($c=0$). 
The resolution for part iii constrains the mesh sizes for part iv. 
While a sample size of six is statistically unreliable, it seems to work quite well for the cell counting method. 
However, the error in numbers produced by Keller's method may be attributed to this small sample size.

\subsection*{Part (v)}
See attached.
For the four values of $c$ chosen, the computer showed that their respective Julia sets were connected because $orb(0)$ did not diverge.

\subsection*{Part (vi)}
The fixed point computation is vectorized via meshgrid for computation savings.
While the value $|z_k|$ in the iteration is less than 100, the iteration count increments by one.
The image is generated by assigning blue values to small iteration count for divergence with a gradation to red for high divergence iteration counts.
Finally, the values that never diverge are colored black.

\subsection*{Part (vii)}
Here, the areas that converge to certain roots of unity, the basins, are color coded.
It can be seen that where the trails converge to in the picture are the roots of unity.
They are marked with asterisks to show that the computation was correct.
The redder (and darker) the color, the faster it was to converge to a root.
As the color changes its shade to blue, the iterations required 
to converge increases.

\subsection*{Part (viii)}
The coloring style is the same as the last section. 
A custom colormap was created from $jet()$ to try and emphasize the border of the set more.
The whole Mandelbrot set is graphed, and a section, that was our best guess as to what was shown on the 1985 Scientific American cover, is also shown.

\end{document}